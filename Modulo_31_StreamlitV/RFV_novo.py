import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime
from PIL import Image
from io import BytesIO
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

@st.cache_data
def convert_df(df):
    return df.to_csv(index=False).encode('utf-8')

# Fun√ß√£o para converter o df para excel
@st.cache_data
def to_excel(df):
    output = BytesIO()
    writer = pd.ExcelWriter(output, engine='xlsxwriter')
    df.to_excel(writer, index=False, sheet_name='Sheet1')
    writer.close()
    processed_data = output.getvalue()
    return processed_data

### Criando os segmentos
def recencia_class(x, r, q_dict):
    """Classifica como melhor o menor quartil 
       x = valor da linha,
       r = recencia,
       q_dict = quartil dicionario   
    """
    if x <= q_dict[r][0.25]:
        return 'A'
    elif x <= q_dict[r][0.50]:
        return 'B'
    elif x <= q_dict[r][0.75]:
        return 'C'
    else:
        return 'D'

def freq_val_class(x, fv, q_dict):
    """Classifica como melhor o maior quartil 
       x = valor da linha,
       fv = frequencia ou valor,
       q_dict = quartil dicionario   
    """
    if x <= q_dict[fv][0.25]:
        return 'D'
    elif x <= q_dict[fv][0.50]:
        return 'C'
    elif x <= q_dict[fv][0.75]:
        return 'B'
    else:
        return 'A'

# Fun√ß√£o principal da aplica√ß√£o
def main():
    # Configura√ß√£o inicial da p√°gina da aplica√ß√£o
    st.set_page_config(page_title = 'RFV', \
        layout="wide",
        initial_sidebar_state='expanded'
    )

    # T√≠tulo principal da aplica√ß√£o
    st.write("""# RFV

    RFV significa rec√™ncia, frequ√™ncia, valor e √© utilizado para segmenta√ß√£o de clientes baseado no comportamento 
    de compras dos clientes e agrupa eles em clusters parecidos. Utilizando esse tipo de agrupamento podemos realizar 
    a√ß√µes de marketing e CRM melhores direcionadas, ajudando assim na personaliza√ß√£o do conte√∫do e at√© a reten√ß√£o de clientes.

    Para cada cliente √© preciso calcular cada uma das componentes abaixo:

    - Rec√™ncia (R): Quantidade de dias desde a √∫ltima compra.
    - Frequ√™ncia (F): Quantidade total de compras no per√≠odo.
    - Valor (V): Total de dinheiro gasto nas compras do per√≠odo.

    E √© isso que iremos fazer abaixo.
    """)
    st.markdown("---")
    
    # Bot√£o para carregar arquivo na aplica√ß√£o
    st.sidebar.write("## Suba o arquivo")
    data_file_1 = st.sidebar.file_uploader("Bank marketing data", type = ['csv','xlsx'])

    # Verifica se h√° conte√∫do carregado na aplica√ß√£o
    if (data_file_1 is not None):
        df_compras = pd.read_csv(data_file_1, infer_datetime_format=True, parse_dates=['DiaCompra'])

        st.write('## Rec√™ncia (R)')

        dia_atual = df_compras['DiaCompra'].max()
        st.write('Dia m√°ximo na base de dados: ', dia_atual)

        df_recencia = df_compras.groupby(by='ID_cliente', as_index=False)['DiaCompra'].max()
        df_recencia.columns = ['ID_cliente','DiaUltimaCompra']
        df_recencia['Recencia'] = df_recencia['DiaUltimaCompra'].apply(lambda x: (dia_atual - x).days)
        df_recencia.drop('DiaUltimaCompra', axis=1, inplace=True)

        st.write('## Frequ√™ncia (F)')
        df_frequencia = df_compras[['ID_cliente','CodigoCompra']].groupby('ID_cliente').count().reset_index()
        df_frequencia.columns = ['ID_cliente','Frequencia']

        st.write('## Valor (V)')
        df_valor = df_compras[['ID_cliente','ValorTotal']].groupby('ID_cliente').sum().reset_index()
        df_valor.columns = ['ID_cliente','Valor']
        
        st.write('## Tabela RFV final')
        df_RF = df_recencia.merge(df_frequencia, on='ID_cliente')
        df_RFV = df_RF.merge(df_valor, on='ID_cliente')
        df_RFV.set_index('ID_cliente', inplace=True)
        st.write(df_RFV.head())

        st.write('## Segmenta√ß√£o utilizando o RFV')
        quartis = df_RFV.quantile(q=[0.25,0.5,0.75])
        st.write(quartis)

        df_RFV['R_quartil'] = df_RFV['Recencia'].apply(recencia_class,
                                                        args=('Recencia', quartis))
        df_RFV['F_quartil'] = df_RFV['Frequencia'].apply(freq_val_class,
                                                        args=('Frequencia', quartis))
        df_RFV['V_quartil'] = df_RFV['Valor'].apply(freq_val_class,
                                                    args=('Valor', quartis))
        df_RFV['RFV_Score'] = (df_RFV.R_quartil 
                            + df_RFV.F_quartil 
                            + df_RFV.V_quartil)
        st.write(df_RFV.head())

        st.write('Quantidade de clientes por grupos')
        st.write(df_RFV['RFV_Score'].value_counts())

        st.write('### An√°lise de Clusters com K-Means')

        # Escalar os dados
        scaler = StandardScaler()
        df_scaled = scaler.fit_transform(df_RFV[['Recencia', 'Frequencia', 'Valor']])

        # Determinar o n√∫mero de clusters
        st.sidebar.write("## Configura√ß√£o do K-Means")
        k = st.sidebar.slider('N√∫mero de clusters', 2, 10, 4)

        # Aplicar o K-Means
        kmeans = KMeans(n_clusters=k, random_state=42)
        df_RFV['Cluster'] = kmeans.fit_predict(df_scaled)

        # Mostrar os clusters
        st.write('Centroides dos clusters:')
        st.write(pd.DataFrame(kmeans.cluster_centers_, columns=['Recencia', 'Frequencia', 'Valor']))

        st.write('Clientes agrupados:')
        st.write(df_RFV.head())

        # Download do arquivo com clusters
        df_xlsx = to_excel(df_RFV)
        st.download_button(label='üì• Download com Clusters',
                            data=df_xlsx,
                            file_name='RFV_Clusters.xlsx')

if __name__ == '__main__':
    main()
